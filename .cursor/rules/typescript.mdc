---
title: "TypeScript 開発ルール"
description: "strictモードの遵守、型安全性、インターフェースと型エイリアスの使い分け、async/awaitの適切な使用、エラーハンドリング、nullチェック、ジェネリクスに関するガイドライン"
tags: ["TypeScript", "型安全性", "strict", "async/await", "エラーハンドリング"]
alwaysApply: true
---

# TypeScript 開発ルール

## 適用タイミング

- 新しいファイルを作成する際
- 関数やクラスを実装する際
- リファクタリング時
- コードレビュー時

## 基本的なルール

### 1. strict モードの遵守

- `tsconfig.json`の`strict: true`設定を維持する
- 型安全性を最優先に考える
- `any`型の使用は最小限に抑える

```typescript
// 良い例
interface SearchResult {
  filePath: string;
  fileName: string;
  matchCount: number;
}

function processSearchResults(results: SearchResult[]): void {
  // 型安全な処理
}

// 悪い例
function processSearchResults(results: any[]): void {
  // any型は避ける
}
```

### 2. 型定義の明示

- 関数の戻り値型を必ず明記する
- 引数の型を明確に定義する
- 変数の型を推論に頼らず明示する（複雑な場合）

```typescript
// 良い例
async function searchFiles(
  pattern: string,
  rootPath: string
): Promise<string[]> {
  const results: string[] = [];
  // 処理...
  return results;
}

// 悪い例
async function searchFiles(pattern, rootPath) {
  const results = [];
  // 処理...
  return results;
}
```

### 3. インターフェースと型エイリアスの使い分け

- オブジェクトの構造を定義する場合は`interface`を使用
- ユニオン型やプリミティブ型のエイリアスには`type`を使用
- 拡張可能性を考慮して`interface`を優先する

```typescript
// 良い例 - interface
interface FileItem {
  label: string;
  resourceUri: vscode.Uri;
  collapsibleState: vscode.TreeItemCollapsibleState;
}

// 良い例 - type
type SearchPattern = string;
type FileExtension = ".ts" | ".tsx" | ".js" | ".jsx";
```

### 4. async/await の適切な使用

- Promise チェーンよりも async/await を優先する
- エラーハンドリングは try-catch で行う
- 並列処理が必要な場合は`Promise.all`を使用する

```typescript
// 良い例
async function performSearch(pattern: string): Promise<void> {
  try {
    const files = await vscode.workspace.findFiles("**/*");
    const filteredFiles = await filterFilesByPattern(files, pattern);
    await updateTreeView(filteredFiles);
  } catch (error) {
    vscode.window.showErrorMessage(`検索エラー: ${error.message}`);
  }
}

// 悪い例
function performSearch(pattern: string): void {
  vscode.workspace
    .findFiles("**/*")
    .then((files) => filterFilesByPattern(files, pattern))
    .then((filteredFiles) => updateTreeView(filteredFiles))
    .catch((error) =>
      vscode.window.showErrorMessage(`検索エラー: ${error.message}`)
    );
}
```

### 5. エラーハンドリングのパターン

- try-catch-finally を適切に使用する
- カスタムエラークラスを作成してエラーの種類を区別する
- エラーメッセージは日本語で分かりやすく記述する
- エラークラスには`code`プロパティを追加してエラーの種類を識別しやすくする
- `cause`プロパティで元のエラーを保持する

```typescript
// 良い例 - カスタムエラークラス群
export class RegexError extends Error {
  public readonly pattern: string;
  public readonly code = 'REGEX_ERROR';

  constructor(message: string, pattern: string) {
    super(message);
    this.name = 'RegexError';
    this.pattern = pattern;
  }
}

export class SearchError extends Error {
  public readonly code = 'SEARCH_ERROR';

  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'SearchError';
  }
}

export class ConfigError extends Error {
  public readonly code = 'CONFIG_ERROR';

  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'ConfigError';
  }
}

export class RenameError extends Error {
  public readonly code = 'RENAME_ERROR';
  public readonly fileUri?: vscode.Uri;

  constructor(message: string, fileUri?: vscode.Uri, public readonly cause?: Error) {
    super(message);
    this.name = 'RenameError';
    this.fileUri = fileUri;
  }
}

// 統一されたエラーハンドラー
export class ErrorHandler {
  static logError(error: Error, context?: string): void {
    const contextMessage = context ? `[${context}] ` : '';
    console.error(`${contextMessage}エラー:`, {
      name: error.name,
      message: error.message,
      stack: error.stack,
      ...(error instanceof RegexError && { pattern: error.pattern }),
      ...(error instanceof RenameError && { fileUri: error.fileUri })
    });
  }

  static async showError(error: Error, context?: string): Promise<void> {
    this.logError(error, context);
    // エラーの種類に応じた適切なメッセージを表示
    if (error instanceof RegexError) {
      const message = `正規表現エラー: ${error.message}\n\n入力されたパターン: "${error.pattern}"`;
      await vscode.window.showErrorMessage(message);
    } else if (error instanceof SearchError) {
      await vscode.window.showErrorMessage(`検索エラー: ${error.message}`);
    } else if (error instanceof ConfigError) {
      await vscode.window.showErrorMessage(`設定エラー: ${error.message}`);
    } else if (error instanceof RenameError) {
      await vscode.window.showErrorMessage(`ファイル名置き換えエラー: ${error.message}`);
    } else if (error.name === 'Canceled') {
      // キャンセルエラーは表示しない
      return;
    } else {
      await vscode.window.showErrorMessage(`エラー: ${error.message}`);
    }
  }
}

async function validateRegex(pattern: string): Promise<void> {
  try {
    new RegExp(pattern);
  } catch (error) {
    throw new RegexError(`無効な正規表現パターン: ${pattern}`, pattern);
  }
}
```

### 6. null チェックと Optional Chaining

- null/undefined の可能性がある値は適切にチェックする
- Optional Chaining (`?.`) を活用する
- Non-null assertion (`!`) は慎重に使用する

```typescript
// 良い例
function getFileExtension(filePath: string): string | undefined {
  const match = filePath.match(/\.([^.]+)$/);
  return match?.[1];
}

// 悪い例
function getFileExtension(filePath: string): string {
  const match = filePath.match(/\.([^.]+)$/);
  return match[1]; // matchがnullの場合にエラー
}
```

### 7. ジェネリクスの適切な使用

- 型安全性を保ちながら再利用性を高める
- 制約（constraints）を適切に設定する
- 複雑になりすぎないよう注意する

```typescript
// 良い例
interface Repository<T> {
  findById(id: string): Promise<T | undefined>;
  save(entity: T): Promise<void>;
}

class FileRepository implements Repository<FileItem> {
  async findById(id: string): Promise<FileItem | undefined> {
    // 実装...
  }

  async save(entity: FileItem): Promise<void> {
    // 実装...
  }
}
```

### 8. 複雑な型定義の管理

- 型定義は`types/index.ts`に集約する
- 関連する型はグループ化する
- Result 型パターンを使用して成功/失敗を型安全に表現する

```typescript
// 良い例 - Result型パターン
export type Result<T, E = Error> = Success<T> | Failure<E>;

export interface Success<T> {
  success: true;
  data: T;
}

export interface Failure<E> {
  success: false;
  error: E;
}

// 使用例
async function performOperation(): Promise<Result<string, RegexError>> {
  try {
    const result = await someAsyncOperation();
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error as RegexError };
  }
}

// 良い例 - ファイル名置き換え関連の型定義
export interface RenamePreview {
  oldUri: vscode.Uri;
  newUri: vscode.Uri;
  oldFileName: string;
  newFileName: string;
  oldPath: string;
  newPath: string;
  needsDirectoryMove: boolean;
}

export interface RenameValidationResult {
  isValid: boolean;
  error?: string;
  warnings?: string[];
  duplicateFiles?: RenamePreview[];
  directoriesToCreate?: vscode.Uri[];
}

export interface RenameHistory {
  fileMapping: Array<{ from: vscode.Uri; to: vscode.Uri }>;
  timestamp: number;
}

export interface RenameResult {
  successCount: number;
  failureCount: number;
  errors?: Array<{ file: vscode.Uri; error: string }>;
}
```

### 9. Undo/Redo パターンの型安全な実装

- 履歴管理を型安全に実装する
- ジェネリクスを使用して再利用可能にする

```typescript
// 良い例 - Undo/Redo機能の実装
export class FileRenameService implements vscode.Disposable {
  private _undoHistory: RenameHistory[] = [];
  private _redoHistory: RenameHistory[] = [];
  private readonly _maxHistorySize = 10;

  async executeRename(previews: RenamePreview[]): Promise<RenameResult> {
    const fileMapping: Array<{ from: vscode.Uri; to: vscode.Uri }> = [];
    let successCount = 0;
    let failureCount = 0;
    const errors: Array<{ file: vscode.Uri; error: string }> = [];

    for (const preview of previews) {
      try {
        await vscode.workspace.fs.rename(preview.oldUri, preview.newUri, { overwrite: false });
        fileMapping.push({ from: preview.oldUri, to: preview.newUri });
        successCount++;
      } catch (error) {
        failureCount++;
        errors.push({
          file: preview.oldUri,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    // 履歴に追加
    if (fileMapping.length > 0) {
      this.addToHistory(fileMapping);
      // Redo履歴をクリア
      this._redoHistory = [];
    }

    return { successCount, failureCount, errors: errors.length > 0 ? errors : undefined };
  }

  async undo(): Promise<void> {
    const lastHistory = this._undoHistory.pop();
    if (!lastHistory) {
      return;
    }

    // 逆順にリネームを実行
    const reverseMapping = lastHistory.fileMapping.slice().reverse();
    // 実装...
    
    // Redo履歴に追加
    this._redoHistory.push(lastHistory);
  }

  private addToHistory(fileMapping: Array<{ from: vscode.Uri; to: vscode.Uri }>): void {
    this._undoHistory.push({
      fileMapping,
      timestamp: Date.now()
    });

    // 履歴サイズ制限
    if (this._undoHistory.length > this._maxHistorySize) {
      this._undoHistory.shift();
    }
  }
}
```

## プロジェクト固有の制約事項

- VS Code API の型定義（`@types/vscode`）を適切に活用する
- 正規表現の型安全性を考慮した設計を行う
- ファイルパスの処理では`vscode.Uri`を使用する
- 非同期処理では適切なエラーハンドリングを実装する
- カスタムエラークラスは`services/errorHandler.ts`に集約する
- 複雑な型定義は`types/index.ts`に集約し、必要に応じてドキュメント化する
- Undo/Redo機能を実装する際は履歴サイズの制限を設ける

## 参考資料

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [VS Code TypeScript API](https://code.visualstudio.com/api/references/vscode-api)
