---
title: "TypeScript 開発ルール"
description: "strictモードの遵守、型安全性、インターフェースと型エイリアスの使い分け、async/awaitの適切な使用、エラーハンドリング、nullチェック、ジェネリクスに関するガイドライン"
tags: ["TypeScript", "型安全性", "strict", "async/await", "エラーハンドリング"]
alwaysApply: true
---

# TypeScript 開発ルール

## 適用タイミング

- 新しいファイルを作成する際
- 関数やクラスを実装する際
- リファクタリング時
- コードレビュー時

## 基本的なルール

### 1. strict モードの遵守

- `tsconfig.json`の`strict: true`設定を維持する
- 型安全性を最優先に考える
- `any`型の使用は最小限に抑える

```typescript
// 良い例
interface SearchResult {
  filePath: string;
  fileName: string;
  matchCount: number;
}

function processSearchResults(results: SearchResult[]): void {
  // 型安全な処理
}

// 悪い例
function processSearchResults(results: any[]): void {
  // any型は避ける
}
```

### 2. 型定義の明示

- 関数の戻り値型を必ず明記する
- 引数の型を明確に定義する
- 変数の型を推論に頼らず明示する（複雑な場合）

```typescript
// 良い例
async function searchFiles(
  pattern: string,
  rootPath: string
): Promise<string[]> {
  const results: string[] = [];
  // 処理...
  return results;
}

// 悪い例
async function searchFiles(pattern, rootPath) {
  const results = [];
  // 処理...
  return results;
}
```

### 3. インターフェースと型エイリアスの使い分け

- オブジェクトの構造を定義する場合は`interface`を使用
- ユニオン型やプリミティブ型のエイリアスには`type`を使用
- 拡張可能性を考慮して`interface`を優先する

```typescript
// 良い例 - interface
interface FileItem {
  label: string;
  resourceUri: vscode.Uri;
  collapsibleState: vscode.TreeItemCollapsibleState;
}

// 良い例 - type
type SearchPattern = string;
type FileExtension = ".ts" | ".tsx" | ".js" | ".jsx";
```

### 4. async/await の適切な使用

- Promise チェーンよりも async/await を優先する
- エラーハンドリングは try-catch で行う
- 並列処理が必要な場合は`Promise.all`を使用する

```typescript
// 良い例
async function performSearch(pattern: string): Promise<void> {
  try {
    const files = await vscode.workspace.findFiles("**/*");
    const filteredFiles = await filterFilesByPattern(files, pattern);
    await updateTreeView(filteredFiles);
  } catch (error) {
    vscode.window.showErrorMessage(`検索エラー: ${error.message}`);
  }
}

// 悪い例
function performSearch(pattern: string): void {
  vscode.workspace
    .findFiles("**/*")
    .then((files) => filterFilesByPattern(files, pattern))
    .then((filteredFiles) => updateTreeView(filteredFiles))
    .catch((error) =>
      vscode.window.showErrorMessage(`検索エラー: ${error.message}`)
    );
}
```

### 5. エラーハンドリングのパターン

- try-catch-finally を適切に使用する
- カスタムエラークラスを作成してエラーの種類を区別する
- エラーメッセージは日本語で分かりやすく記述する
- エラークラスには`code`プロパティを追加してエラーの種類を識別しやすくする
- `cause`プロパティで元のエラーを保持する

```typescript
// 良い例 - カスタムエラークラス群
export class RegexError extends Error {
  public readonly pattern: string;
  public readonly code = 'REGEX_ERROR';

  constructor(message: string, pattern: string) {
    super(message);
    this.name = 'RegexError';
    this.pattern = pattern;
  }
}

export class SearchError extends Error {
  public readonly code = 'SEARCH_ERROR';

  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'SearchError';
  }
}

export class ConfigError extends Error {
  public readonly code = 'CONFIG_ERROR';

  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'ConfigError';
  }
}

export class RenameError extends Error {
  public readonly code = 'RENAME_ERROR';
  public readonly fileUri?: vscode.Uri;

  constructor(message: string, fileUri?: vscode.Uri, public readonly cause?: Error) {
    super(message);
    this.name = 'RenameError';
    this.fileUri = fileUri;
  }
}

// 統一されたエラーハンドラー
export class ErrorHandler {
  static logError(error: Error, context?: string): void {
    const contextMessage = context ? `[${context}] ` : '';
    console.error(`${contextMessage}エラー:`, {
      name: error.name,
      message: error.message,
      stack: error.stack,
      ...(error instanceof RegexError && { pattern: error.pattern }),
      ...(error instanceof RenameError && { fileUri: error.fileUri })
    });
  }

  static async showError(error: Error, context?: string): Promise<void> {
    this.logError(error, context);
    // エラーの種類に応じた適切なメッセージを表示
    if (error instanceof RegexError) {
      const message = `正規表現エラー: ${error.message}\n\n入力されたパターン: "${error.pattern}"`;
      await vscode.window.showErrorMessage(message);
    } else if (error instanceof SearchError) {
      await vscode.window.showErrorMessage(`検索エラー: ${error.message}`);
    } else if (error instanceof ConfigError) {
      await vscode.window.showErrorMessage(`設定エラー: ${error.message}`);
    } else if (error instanceof RenameError) {
      await vscode.window.showErrorMessage(`ファイル名置き換えエラー: ${error.message}`);
    } else if (error.name === 'Canceled') {
      // キャンセルエラーは表示しない
      return;
    } else {
      await vscode.window.showErrorMessage(`エラー: ${error.message}`);
    }
  }

  /**
   * エラーを安全にキャッチして処理（非同期処理用）
   */
  static async handleAsync<T>(
    operation: () => Promise<T>,
    context?: string,
    fallback?: T
  ): Promise<T | undefined> {
    try {
      return await operation();
    } catch (error) {
      // キャンセルエラーは無視（拡張機能終了時の正常な動作）
      if (error instanceof Error && error.name === 'Canceled') {
        return fallback;
      }

      if (error instanceof Error) {
        await this.showError(error, context);
      } else {
        await this.showError(new Error('Unknown error'), context);
      }
      return fallback;
    }
  }

  /**
   * エラーを安全にキャッチして処理（同期的処理用）
   */
  static handleSync<T>(
    operation: () => T,
    context?: string,
    fallback?: T
  ): T | undefined {
    try {
      return operation();
    } catch (error) {
      if (error instanceof Error) {
        this.logError(error, context);
        if (context) {
          vscode.window.showErrorMessage(`${context}: ${error.message}`);
        }
      }
      return fallback;
    }
  }
}

async function validateRegex(pattern: string): Promise<void> {
  try {
    new RegExp(pattern);
  } catch (error) {
    throw new RegexError(`無効な正規表現パターン: ${pattern}`, pattern);
  }
}
```

**ErrorHandler.handleAsync()の使用例：**

コマンド登録や非同期処理でエラーを統一して処理する場合に使用する：

```typescript
// 良い例 - コマンド登録での使用
import { ErrorHandler } from './services/errorHandler';

export function registerSearchCommands(
  context: vscode.ExtensionContext,
  treeProvider: SearchTreeProvider
): void {
  // 検索実行
  context.subscriptions.push(
    vscode.commands.registerCommand(
      'regexFileFinder.executeSearch',
      async () => {
        await ErrorHandler.handleAsync(async () => {
          await treeProvider.executeSearch();
        }, 'SearchCommands.executeSearch');
      }
    )
  );

  // 検索結果クリア
  context.subscriptions.push(
    vscode.commands.registerCommand(
      'regexFileFinder.clearResults',
      async () => {
        await ErrorHandler.handleAsync(async () => {
          treeProvider.clearResults();
        }, 'SearchCommands.clearResults');
      }
    )
  );
}

// 良い例 - サービス内での使用
export class FileSearchService {
  async searchFiles(pattern: string): Promise<SearchResult[]> {
    return await ErrorHandler.handleAsync(
      async () => {
        // 検索処理
        const files = await this.performSearch(pattern);
        return files;
      },
      'FileSearchService.searchFiles',
      [] // エラー時のフォールバック値
    ) || [];
  }
}
```

**ErrorHandler.handleAsync()の特徴：**

- 非同期処理を安全に実行し、エラーを自動的に処理
- キャンセルエラー（`Canceled`）は無視する
- エラーが発生した場合は`ErrorHandler.showError()`でユーザーに通知
- フォールバック値を指定可能
- コンテキスト文字列を指定してエラーの発生箇所を記録

**ErrorHandler.handleSync()の使用例：**

同期的処理でエラーを処理する場合に使用する：

```typescript
// 良い例 - 同期的処理での使用
export class ConfigService {
  getSearchPattern(): string {
    return ErrorHandler.handleSync(
      () => {
        const config = vscode.workspace.getConfiguration('regexFileFinder');
        return config.get<string>('searchPattern', '');
      },
      'ConfigService.getSearchPattern',
      '' // エラー時のフォールバック値
    ) || '';
  }
}
```

### 6. null チェックと Optional Chaining

- null/undefined の可能性がある値は適切にチェックする
- Optional Chaining (`?.`) を活用する
- Non-null assertion (`!`) は慎重に使用する

```typescript
// 良い例
function getFileExtension(filePath: string): string | undefined {
  const match = filePath.match(/\.([^.]+)$/);
  return match?.[1];
}

// 悪い例
function getFileExtension(filePath: string): string {
  const match = filePath.match(/\.([^.]+)$/);
  return match[1]; // matchがnullの場合にエラー
}
```

### 7. ジェネリクスの適切な使用

- 型安全性を保ちながら再利用性を高める
- 制約（constraints）を適切に設定する
- 複雑になりすぎないよう注意する

```typescript
// 良い例
interface Repository<T> {
  findById(id: string): Promise<T | undefined>;
  save(entity: T): Promise<void>;
}

class FileRepository implements Repository<FileItem> {
  async findById(id: string): Promise<FileItem | undefined> {
    // 実装...
  }

  async save(entity: FileItem): Promise<void> {
    // 実装...
  }
}
```

### 8. 複雑な型定義の管理

- 型定義は`types/index.ts`に集約する
- 関連する型はグループ化する
- Result 型パターンを使用して成功/失敗を型安全に表現する

```typescript
// 良い例 - Result型パターン
export type Result<T, E = Error> = Success<T> | Failure<E>;

export interface Success<T> {
  success: true;
  data: T;
}

export interface Failure<E> {
  success: false;
  error: E;
}

// 使用例 - 基本的な使用
async function performOperation(): Promise<Result<string, RegexError>> {
  try {
    const result = await someAsyncOperation();
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error as RegexError };
  }
}

// 使用例 - FileSearchServiceでの実装パターン
export class FileSearchService {
  async searchFiles(
    params: SearchParams,
    options: SearchOptions = {}
  ): Promise<Result<SearchResult, SearchError>> {
    try {
      // 検索パターンのバリデーション
      const validation = RegexValidator.validate(params.searchPattern);
      if (!validation.isValid) {
        return {
          success: false,
          error: new SearchError(validation.error || '無効な正規表現パターン')
        };
      }

      // ファイル検索を実行
      const files = await this.performFileSearch(params, options);

      const result: SearchResult = {
        files,
        totalCount: files.length,
        searchTime: Date.now(),
        pattern: params.searchPattern,
      };

      return {
        success: true,
        data: result,
      };
    } catch (error) {
      const searchError =
        error instanceof SearchError
          ? error
          : new SearchError('検索に失敗しました', error instanceof Error ? error : new Error('Unknown error'));

      return {
        success: false,
        error: searchError,
      };
    }
  }

  // 使用側での処理
  async executeSearch(): Promise<void> {
    const result = await this._fileSearchService.searchFiles(searchParams);

    if (result.success) {
      // 成功時の処理
      const searchResult = result.data;
      Logger.logInfo(`検索完了: ${searchResult.totalCount}件見つかりました`, 'SearchTreeProvider');
      this.updateSearchResults(searchResult.files);
    } else {
      // 失敗時の処理
      Logger.logError(result.error, 'SearchTreeProvider.executeSearch');
      await ErrorHandler.showError(result.error, 'SearchTreeProvider.executeSearch');
    }
  }
}
```

**Result型パターンの特徴：**

- 成功/失敗を型安全に表現できる
- エラーの種類を型で指定可能（例: `Result<T, SearchError>`）
- 呼び出し側で`result.success`をチェックして分岐
- `result.data`で成功時のデータにアクセス
- `result.error`で失敗時のエラーにアクセス
- try-catchの代わりに使用することで、エラーハンドリングを統一できる

// 良い例 - ファイル名置き換え関連の型定義
export interface RenamePreview {
  oldUri: vscode.Uri;
  newUri: vscode.Uri;
  oldFileName: string;
  newFileName: string;
  oldPath: string;
  newPath: string;
  needsDirectoryMove: boolean;
}

export interface RenameValidationResult {
  isValid: boolean;
  error?: string;
  warnings?: string[];
  duplicateFiles?: RenamePreview[];
  directoriesToCreate?: vscode.Uri[];
}

export interface RenameHistory {
  fileMapping: Array<{ from: vscode.Uri; to: vscode.Uri }>;
  timestamp: number;
}

export interface RenameResult {
  successCount: number;
  failureCount: number;
  errors?: Array<{ file: vscode.Uri; error: string }>;
}
```

### 9. Undo/Redo パターンの型安全な実装

- 履歴管理を型安全に実装する
- ジェネリクスを使用して再利用可能にする

```typescript
// 良い例 - Undo/Redo機能の実装
export class FileRenameService implements vscode.Disposable {
  private _undoHistory: RenameHistory[] = [];
  private _redoHistory: RenameHistory[] = [];
  private readonly _maxHistorySize = 10;

  async executeRename(previews: RenamePreview[]): Promise<RenameResult> {
    const fileMapping: Array<{ from: vscode.Uri; to: vscode.Uri }> = [];
    let successCount = 0;
    let failureCount = 0;
    const errors: Array<{ file: vscode.Uri; error: string }> = [];

    for (const preview of previews) {
      try {
        await vscode.workspace.fs.rename(preview.oldUri, preview.newUri, { overwrite: false });
        fileMapping.push({ from: preview.oldUri, to: preview.newUri });
        successCount++;
      } catch (error) {
        failureCount++;
        errors.push({
          file: preview.oldUri,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    // 履歴に追加
    if (fileMapping.length > 0) {
      this.addToHistory(fileMapping);
      // Redo履歴をクリア
      this._redoHistory = [];
    }

    return { successCount, failureCount, errors: errors.length > 0 ? errors : undefined };
  }

  async undo(): Promise<void> {
    const lastHistory = this._undoHistory.pop();
    if (!lastHistory) {
      return;
    }

    // 逆順にリネームを実行
    const reverseMapping = lastHistory.fileMapping.slice().reverse();
    // 実装...
    
    // Redo履歴に追加
    this._redoHistory.push(lastHistory);
  }

  private addToHistory(fileMapping: Array<{ from: vscode.Uri; to: vscode.Uri }>): void {
    this._undoHistory.push({
      fileMapping,
      timestamp: Date.now()
    });

    // 履歴サイズ制限
    if (this._undoHistory.length > this._maxHistorySize) {
      this._undoHistory.shift();
    }
  }

  /**
   * Undo可能かチェック
   */
  canUndo(): boolean {
    return this._undoHistory.length > 0;
  }

  /**
   * Redo可能かチェック
   */
  canRedo(): boolean {
    return this._redoHistory.length > 0;
  }

  /**
   * Undo: 最後の置き換えを元に戻す
   */
  async undo(): Promise<RenameResult> {
    if (!this.canUndo()) {
      throw new RenameError(ERROR_MESSAGES.NO_UNDO_HISTORY);
    }

    const lastHistory = this._undoHistory.pop()!;
    const errors: Array<{ file: vscode.Uri; error: string }> = [];
    let successCount = 0;

    // 逆順に元に戻す
    for (const { from, to } of lastHistory.fileMapping.reverse()) {
      try {
        await vscode.workspace.fs.rename(to, from, { overwrite: false });
        successCount++;
      } catch (error) {
        errors.push({
          file: to,
          error: error instanceof Error ? error.message : '不明なエラーが発生しました'
        });
      }
    }

    // Redo履歴に追加
    this._redoHistory.push(lastHistory);

    return {
      successCount,
      failureCount: lastHistory.fileMapping.length - successCount,
      errors: errors.length > 0 ? errors : undefined
    };
  }

  /**
   * Redo: やり直す
   */
  async redo(): Promise<RenameResult> {
    if (!this.canRedo()) {
      throw new RenameError(ERROR_MESSAGES.NO_REDO_HISTORY);
    }

    const lastHistory = this._redoHistory.pop()!;
    const errors: Array<{ file: vscode.Uri; error: string }> = [];
    let successCount = 0;

    // 再度実行
    for (const { from, to } of lastHistory.fileMapping) {
      try {
        await vscode.workspace.fs.rename(from, to, { overwrite: false });
        successCount++;
      } catch (error) {
        errors.push({
          file: from,
          error: error instanceof Error ? error.message : '不明なエラーが発生しました'
        });
      }
    }

    // Undo履歴に追加
    this._undoHistory.push(lastHistory);

    return {
      successCount,
      failureCount: lastHistory.fileMapping.length - successCount,
      errors: errors.length > 0 ? errors : undefined
    };
  }
}
```

**Undo/Redo機能の特徴：**

- 履歴は`RenameHistory`型で管理（`fileMapping`と`timestamp`を含む）
- 最大10件の履歴を保持（`_maxHistorySize`で制限）
- Undo時に逆順に実行（`reverse()`を使用）
- 新しい操作が行われた場合はRedo履歴をクリア
- `canUndo()`と`canRedo()`で操作可能性をチェック
- エラー時は詳細なエラー情報を返す

### 10. ログ出力機能（Logger）の使用

- すべてのログ出力は`Logger`の静的メソッドを使用する
- シングルトンパターンで実装されており、`Logger.initialize()`で初期化する
- LogLevel enumを使用してログレベルを管理する

```typescript
// 良い例 - Loggerの初期化と使用
import { Logger, LogLevel } from './services/logger';

// extension.ts - 初期化
export async function activate(context: vscode.ExtensionContext): Promise<void> {
  // Loggerの初期化（ExtensionContextを設定）
  Logger.initialize(context);
  
  // Loggerをコンテキストに追加（クリーンアップ用）
  const logger = Logger.getInstance();
  if (logger) {
    context.subscriptions.push(logger);
  }
}

// サービス・プロバイダーでの使用
import { Logger } from '../services/logger';

// エラーログ（Errorオブジェクト）
try {
  await someOperation();
} catch (error) {
  Logger.logError(
    error instanceof Error ? error : new Error(String(error)),
    'ServiceName.methodName'
  );
}

// 警告ログ（文字列）
if (complexity === 'high') {
  Logger.logWarning('正規表現が複雑です', 'RegexValidator');
}

// 情報ログ（文字列）
Logger.logInfo('検索を開始しました', 'FileSearchService');

// デバッグログ（文字列）
Logger.logDebug(`検索パターン: ${pattern}`, 'FileSearchService');
```

**Loggerの特徴：**

- シングルトンパターンで実装（`Logger.getInstance()`で取得）
- 静的メソッドでログ出力（`Logger.logError()`, `Logger.logWarning()`, `Logger.logInfo()`, `Logger.logDebug()`）
- OutputChannelとコンソールの両方に出力
- 設定でログファイルへの出力も可能（`regexFileFinder.logFileEnabled`）
- ログレベルに応じて出力を制御（`regexFileFinder.logLevel`）
- エラーログは自動的にOutputChannelを表示
- Loggerが利用できない場合はconsoleにフォールバック

## プロジェクト固有の制約事項

- VS Code API の型定義（`@types/vscode`）を適切に活用する
- 正規表現の型安全性を考慮した設計を行う
- ファイルパスの処理では`vscode.Uri`を使用する
- 非同期処理では適切なエラーハンドリングを実装する
- カスタムエラークラスは`services/errorHandler.ts`に集約する
- 複雑な型定義は`types/index.ts`に集約し、必要に応じてドキュメント化する
- Undo/Redo機能を実装する際は履歴サイズの制限を設ける

## 参考資料

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [VS Code TypeScript API](https://code.visualstudio.com/api/references/vscode-api)
