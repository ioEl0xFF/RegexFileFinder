---
title: 'プロジェクト構造とアーキテクチャルール'
description: 'ディレクトリ構成、責任分離、ファイル命名規則、モジュール間依存関係、インポート順序、型定義管理、設定分離、エラーハンドリング統一に関するガイドライン'
tags: ['プロジェクト構造', 'アーキテクチャ', '責任分離', '命名規則', '依存関係']
alwaysApply: true
---

# プロジェクト構造とアーキテクチャルール

## 適用タイミング

- 新しいファイルやディレクトリを作成する際
- モジュールを追加する際
- リファクタリング時
- アーキテクチャの見直し時

## 基本的なルール

### 1. ディレクトリ構成

プロジェクトのディレクトリ構造は以下のように整理する：

```
src/
├── commands/          # コマンド実装
│   └── searchCommands.ts
├── providers/         # TreeDataProvider等のプロバイダー
│   ├── searchTreeProvider.ts
│   └── searchInputViewProvider.ts
├── services/          # ビジネスロジック
│   ├── fileSearchService.ts
│   ├── configService.ts
│   ├── errorHandler.ts
│   └── fileRenameService.ts
├── utils/            # ユーティリティ関数
│   ├── regexValidator.ts
│   └── treeBuilder.ts
├── types/            # 型定義
│   └── index.ts
└── extension.ts      # エントリーポイント
```

### 2. 責任分離の原則（Single Responsibility）

各モジュールは単一の責任を持つように設計する：

```typescript
// 良い例 - 責任が明確に分離されている
// commands/searchCommands.ts - コマンドの登録のみ
export function registerSearchCommands(
  context: vscode.ExtensionContext,
  treeProvider: SearchTreeProvider,
  inputProvider: SearchInputViewProvider
): void {
  const disposables = [
    vscode.commands.registerCommand(
      'regexFileFinder.executeSearch',
      async () => {
        await treeProvider.executeSearch();
      }
    ),
    vscode.commands.registerCommand('regexFileFinder.clearResults', () => {
      treeProvider.clearResults();
    }),
    // ... その他のコマンド
  ];
  disposables.forEach((d) => context.subscriptions.push(d));
}

// services/fileSearchService.ts - ファイル検索ロジックのみ
export class FileSearchService {
  async searchFiles(pattern: string): Promise<vscode.Uri[]> {
    // 検索ロジック
  }
}

// providers/searchTreeProvider.ts - UI表示のみ
export class SearchTreeProvider implements vscode.TreeDataProvider<TreeNode> {
  // TreeDataProviderの実装
}

// utils/regexValidator.ts - 正規表現バリデーションのみ
export class RegexValidator {
  static validate(pattern: string): RegexValidationResult {
    // バリデーションロジック
  }
}
```

### 3. ファイル命名規則

- TypeScript ファイルは`camelCase.ts`形式を使用
- クラス名は`PascalCase`
- 関数・変数名は`camelCase`
- 定数は`UPPER_SNAKE_CASE`

```typescript
// 良い例
// ファイル名: fileSearchService.ts
export class FileSearchService {
  private readonly MAX_RESULTS = 1000;

  async searchFiles(pattern: string): Promise<string[]> {
    // 実装
  }
}
```

### 4. モジュール間の依存関係

依存関係は以下の方向に限定する：

```
extension.ts
    ↓
commands/ → providers/ → services/
    ↓           ↓           ↓       ↓
types/ ← types/ ← types/ ← utils/
```

- `commands`は`providers`と`types`に依存可能
- `providers`は`services`、`utils`と`types`に依存可能
- `services`は`utils`と`types`に依存可能
- `utils`は`types`のみに依存可能（必要に応じて`services`のエラークラスに依存可能）
- `types`は他のモジュールに依存しない

```typescript
// 良い例 - 依存関係が適切
// commands/searchCommands.ts
import { SearchTreeProvider } from '../providers/searchTreeProvider';
import { SearchResult } from '../types';

// providers/searchTreeProvider.ts
import { FileSearchService } from '../services/fileSearchService';
import { TreeBuilder } from '../utils/treeBuilder';
import { TreeNode } from '../types';

// services/fileSearchService.ts
import { SearchResult } from '../types';

// utils/regexValidator.ts
import { RegexValidationResult } from '../types';
import { RegexError } from '../services/errorHandler';
```

### 5. インポート順序

インポートは以下の順序で記述する：

```typescript
// 1. VS Code API
import * as vscode from 'vscode';

// 2. 外部ライブラリ（現在は使用していない）
// import axios from 'axios';

// 3. 内部モジュール（相対パス）
import { FileSearchService } from '../services/fileSearchService';
import { FileTreeProvider } from '../providers/fileTreeProvider';

// 4. 型定義
import type { FileItem, SearchResult } from '../types';
```

### 6. 型定義の管理

型定義は`types/index.ts`に集約し、必要に応じて分割する：

```typescript
// types/index.ts
export interface FileItem {
  label: string;
  resourceUri: vscode.Uri;
  collapsibleState: vscode.TreeItemCollapsibleState;
}

export interface SearchResult {
  filePath: string;
  fileName: string;
  matchCount: number;
}

export type SearchPattern = string;
export type FileExtension = '.ts' | '.tsx' | '.js' | '.jsx';
```

### 7. 設定とコンフィギュレーション

設定関連のコードは適切に分離する：

```typescript
// 良い例 - 設定を分離
export class ConfigService implements vscode.Disposable {
  private readonly _disposables: vscode.Disposable[] = [];
  private readonly _configKey = 'regexFileFinder';
  private _searchParams: SearchParams = {
    searchPattern: '',
    includeFolders: [],
    excludeFolders: [],
  };

  constructor() {
    this.loadConfig();
    this.setupConfigWatcher();
  }

  get searchParams(): Readonly<SearchParams> {
    return { ...this._searchParams };
  }

  async setSearchPattern(pattern: string): Promise<void> {
    this._searchParams.searchPattern = pattern;
    await this.saveConfig();
  }

  private async saveConfig(): Promise<void> {
    const config = vscode.workspace.getConfiguration(this._configKey);
    await config.update(
      'searchPattern',
      this._searchParams.searchPattern,
      true
    );
  }

  dispose(): void {
    this._disposables.forEach((d) => d.dispose());
    this._disposables = [];
  }
}
```

### 8. エラーハンドリングの統一

エラーハンドリングは統一されたパターンを使用する：

```typescript
// 良い例 - 統一されたエラーハンドリング
// カスタムエラークラス
export class RegexError extends Error {
  public readonly pattern: string;
  public readonly code = 'REGEX_ERROR';

  constructor(message: string, pattern: string) {
    super(message);
    this.name = 'RegexError';
    this.pattern = pattern;
  }
}

export class SearchError extends Error {
  public readonly code = 'SEARCH_ERROR';
  constructor(
    message: string,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'SearchError';
  }
}

// 統一されたエラーハンドラー
export class ErrorHandler {
  static logError(error: Error, context?: string): void {
    const contextMessage = context ? `[${context}] ` : '';
    console.error(`${contextMessage}エラー:`, {
      name: error.name,
      message: error.message,
      stack: error.stack,
    });
  }

  static async showError(error: Error, context?: string): Promise<void> {
    this.logError(error, context);
    // エラーの種類に応じた適切なメッセージを表示
    if (error instanceof RegexError) {
      vscode.window.showErrorMessage(`正規表現エラー: ${error.message}`);
    } else if (error instanceof SearchError) {
      vscode.window.showErrorMessage(`検索エラー: ${error.message}`);
    }
  }
}
```

### 9. ユーティリティ関数の配置

再利用可能な関数は`utils/`ディレクトリに配置する：

```typescript
// 良い例 - ユーティリティ関数の分離
// utils/regexValidator.ts - 正規表現バリデーション専用
export class RegexValidator {
  static validate(pattern: string): RegexValidationResult {
    // バリデーションロジック
  }

  static createRegex(pattern: string, flags?: string): RegExp {
    // 安全な正規表現作成
  }
}

// utils/treeBuilder.ts - ツリー構築専用
export class TreeBuilder {
  static buildFileTree(
    files: vscode.Uri[],
    options: TreeBuildOptions = {}
  ): TreeNode[] {
    // ツリー構築ロジック
  }
}
```

**utils/の使用指針:**

- 特定のドメインに依存しない汎用的な関数
- 複数のモジュールから使用される共通処理
- 単体テストが容易な純粋関数を推奨
- サービス層とは異なり、状態を持たない静的メソッドを推奨

## プロジェクト固有の制約事項

- RegexFileFinder は単一機能の拡張機能として設計（v2.0.0以降は検索とリネーム機能を含む）
- 複雑な依存関係は避け、シンプルな構造を維持
- VS Code 拡張機能の制約（バンドルサイズ、パフォーマンス）を考慮
- 将来の機能拡張を考慮した柔軟な設計
- Webview を使用した UI 実装（SearchInputViewProvider）を含む

## 参考資料

- [VS Code Extension Structure](https://code.visualstudio.com/api/extension-guides/overview)
- [Clean Architecture Principles](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
