---
title: 'プロジェクト構造とアーキテクチャルール'
description: 'ディレクトリ構成、責任分離、ファイル命名規則、モジュール間依存関係、インポート順序、型定義管理、設定分離、エラーハンドリング統一に関するガイドライン'
tags: ['プロジェクト構造', 'アーキテクチャ', '責任分離', '命名規則', '依存関係']
alwaysApply: true
---

# プロジェクト構造とアーキテクチャルール

## 適用タイミング

- 新しいファイルやディレクトリを作成する際
- モジュールを追加する際
- リファクタリング時
- アーキテクチャの見直し時

## 基本的なルール

### 1. ディレクトリ構成

プロジェクトのディレクトリ構造は以下のように整理する：

```
src/
├── commands/          # コマンド実装
│   └── searchCommands.ts
├── providers/         # TreeDataProvider等のプロバイダー
│   ├── searchTreeProvider.ts
│   └── searchInputViewProvider.ts
├── services/          # ビジネスロジック
│   ├── fileSearchService.ts
│   ├── configService.ts
│   ├── errorHandler.ts
│   └── fileRenameService.ts
├── utils/            # ユーティリティ関数
│   ├── regexValidator.ts
│   ├── treeBuilder.ts
│   └── i18n.ts
├── types/            # 型定義
│   └── index.ts
└── extension.ts      # エントリーポイント
```

### 2. 責任分離の原則（Single Responsibility）

各モジュールは単一の責任を持つように設計する：

```typescript
// 良い例 - 責任が明確に分離されている
// commands/searchCommands.ts - コマンドの登録のみ
export function registerSearchCommands(
  context: vscode.ExtensionContext,
  treeProvider: SearchTreeProvider,
  inputProvider: SearchInputViewProvider
): void {
  const disposables = [
    vscode.commands.registerCommand(
      'regexFileFinder.executeSearch',
      async () => {
        await treeProvider.executeSearch();
      }
    ),
    vscode.commands.registerCommand('regexFileFinder.clearResults', () => {
      treeProvider.clearResults();
    }),
    // ... その他のコマンド
  ];
  disposables.forEach((d) => context.subscriptions.push(d));
}

// services/fileSearchService.ts - ファイル検索ロジックのみ
export class FileSearchService {
  async searchFiles(pattern: string): Promise<vscode.Uri[]> {
    // 検索ロジック
  }
}

// providers/searchTreeProvider.ts - UI表示のみ
export class SearchTreeProvider implements vscode.TreeDataProvider<TreeNode> {
  // TreeDataProviderの実装
}

// utils/regexValidator.ts - 正規表現バリデーションのみ
export class RegexValidator {
  static validate(pattern: string): RegexValidationResult {
    // バリデーションロジック
  }
}
```

### 3. ファイル命名規則

- TypeScript ファイルは`camelCase.ts`形式を使用
- クラス名は`PascalCase`
- 関数・変数名は`camelCase`
- 定数は`UPPER_SNAKE_CASE`

```typescript
// 良い例
// ファイル名: fileSearchService.ts
export class FileSearchService {
  private readonly MAX_RESULTS = 1000;

  async searchFiles(pattern: string): Promise<string[]> {
    // 実装
  }
}
```

### 4. モジュール間の依存関係

依存関係は以下の方向に限定する：

```
extension.ts
    ↓
commands/ → providers/ → services/
    ↓           ↓           ↓       ↓
types/ ← types/ ← types/ ← utils/
```

- `commands`は`providers`と`types`に依存可能
- `providers`は`services`、`utils`と`types`に依存可能
- `services`は`utils`と`types`に依存可能
- `utils`は`types`のみに依存可能（必要に応じて`services`のエラークラスに依存可能）
- `types`は他のモジュールに依存しない

```typescript
// 良い例 - 依存関係が適切
// commands/searchCommands.ts
import { SearchTreeProvider } from '../providers/searchTreeProvider';
import { SearchResult } from '../types';

// providers/searchTreeProvider.ts
import { FileSearchService } from '../services/fileSearchService';
import { TreeBuilder } from '../utils/treeBuilder';
import { TreeNode } from '../types';

// services/fileSearchService.ts
import { SearchResult } from '../types';

// utils/regexValidator.ts
import { RegexValidationResult } from '../types';
import { RegexError } from '../services/errorHandler';
```

### 5. インポート順序

インポートは以下の順序で記述する：

```typescript
// 1. VS Code API
import * as vscode from 'vscode';

// 2. 外部ライブラリ（現在は使用していない）
// import axios from 'axios';

// 3. 内部モジュール（相対パス）
import { FileSearchService } from '../services/fileSearchService';
import { FileTreeProvider } from '../providers/fileTreeProvider';

// 4. 型定義
import type { FileItem, SearchResult } from '../types';
```

### 6. 型定義の管理

型定義は`types/index.ts`に集約し、必要に応じて分割する：

```typescript
// types/index.ts
export interface FileItem {
  label: string;
  resourceUri: vscode.Uri;
  collapsibleState: vscode.TreeItemCollapsibleState;
}

export interface SearchResult {
  filePath: string;
  fileName: string;
  matchCount: number;
}

export type SearchPattern = string;
export type FileExtension = '.ts' | '.tsx' | '.js' | '.jsx';
```

### 7. 設定とコンフィギュレーション

設定関連のコードは適切に分離する：

```typescript
// 良い例 - 設定を分離
import { Logger } from './logger';
import { t } from '../utils/i18n';
import { ConfigError, ERROR_MESSAGES } from './errorHandler';

export class ConfigService implements vscode.Disposable {
  private readonly _disposables: vscode.Disposable[] = [];
  private readonly _configKey = 'regexFileFinder';
  private _searchParams: SearchParams = {
    searchPattern: '',
    includeFolders: [],
    excludeFolders: [],
  };
  private _replacementString = '';

  constructor() {
    this.loadConfig();
    this.setupConfigWatcher();
  }

  get searchParams(): Readonly<SearchParams> {
    return { ...this._searchParams };
  }

  get replacementString(): string {
    return this._replacementString;
  }

  async setSearchPattern(pattern: string): Promise<void> {
    this._searchParams.searchPattern = pattern;
    await this.saveConfig();
  }

  async setIncludeFolders(folders: string[]): Promise<void> {
    this._searchParams.includeFolders = folders;
    await this.saveConfig();
  }

  async setExcludeFolders(folders: string[]): Promise<void> {
    this._searchParams.excludeFolders = folders;
    await this.saveConfig();
  }

  async setReplacementString(replacement: string): Promise<void> {
    this._replacementString = replacement;
    await this.saveConfig();
  }

  private async saveConfig(): Promise<void> {
    try {
      const config = vscode.workspace.getConfiguration(this._configKey);

      // ワークスペースが開かれている場合はワークスペース設定を優先、そうでなければグローバル設定を使用
      const target =
        vscode.workspace.workspaceFolders &&
        vscode.workspace.workspaceFolders.length > 0
          ? vscode.ConfigurationTarget.Workspace
          : vscode.ConfigurationTarget.Global;

      await config.update(
        'searchPattern',
        this._searchParams.searchPattern,
        target
      );
      await config.update(
        'includeFolders',
        this._searchParams.includeFolders,
        target
      );
      await config.update(
        'excludeFolders',
        this._searchParams.excludeFolders,
        target
      );
      await config.update('replacementString', this._replacementString, target);
    } catch (error) {
      Logger.logError(
        error instanceof Error ? error : new Error(t('errors.unknownError')),
        'ConfigService.saveConfig'
      );
      throw new ConfigError(
        ERROR_MESSAGES.CONFIG_SAVE_ERROR,
        error instanceof Error ? error : new Error(t('errors.unknownError'))
      );
    }
  }

  private loadConfig(): void {
    try {
      const config = vscode.workspace.getConfiguration(this._configKey);
      this._searchParams = {
        searchPattern: config.get('searchPattern', ''),
        includeFolders: config.get('includeFolders', []) || [],
        excludeFolders: config.get('excludeFolders', []) || [],
      };
      this._replacementString = config.get('replacementString', '');
    } catch (error) {
      Logger.logWarning('設定読み込みエラーが発生しました', 'ConfigService');
      Logger.logError(
        error instanceof Error ? error : new Error(String(error)),
        'ConfigService.loadConfig'
      );
      // デフォルト値を使用（エラーを再スローしない）
      this._searchParams = {
        searchPattern: '',
        includeFolders: [],
        excludeFolders: [],
      };
      this._replacementString = '';
    }
  }

  private setupConfigWatcher(): void {
    const disposable = vscode.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration(this._configKey)) {
        this.loadConfig();
      }
    });
    this._disposables.push(disposable);
  }

  dispose(): void {
    this._disposables.forEach((d) => d.dispose());
    this._disposables = [];
  }
}
```

**ConfigServiceの特徴：**

- 設定変更を監視（`onDidChangeConfiguration`）して自動的に再読み込み
- ワークスペースが開かれている場合はワークスペース設定を優先、そうでなければグローバル設定を使用
- 設定の読み込みエラー時はデフォルト値を使用（エラーを再スローしない）
- `replacementString`も管理（ファイル名置き換え機能用）
- 設定の保存時は適切なエラーハンドリングを実施

### 8. エラーハンドリングの統一

エラーハンドリングは統一されたパターンを使用する：

```typescript
// 良い例 - 統一されたエラーハンドリング
// カスタムエラークラス
export class RegexError extends Error {
  public readonly pattern: string;
  public readonly code = 'REGEX_ERROR';

  constructor(message: string, pattern: string) {
    super(message);
    this.name = 'RegexError';
    this.pattern = pattern;
  }
}

export class SearchError extends Error {
  public readonly code = 'SEARCH_ERROR';
  constructor(
    message: string,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'SearchError';
  }
}

// 統一されたエラーハンドラー
export class ErrorHandler {
  static logError(error: Error, context?: string): void {
    const contextMessage = context ? `[${context}] ` : '';
    console.error(`${contextMessage}エラー:`, {
      name: error.name,
      message: error.message,
      stack: error.stack,
    });
  }

  static async showError(error: Error, context?: string): Promise<void> {
    this.logError(error, context);
    // エラーの種類に応じた適切なメッセージを表示
    if (error instanceof RegexError) {
      vscode.window.showErrorMessage(`正規表現エラー: ${error.message}`);
    } else if (error instanceof SearchError) {
      vscode.window.showErrorMessage(`検索エラー: ${error.message}`);
    }
  }
}
```

### 9. ユーティリティ関数の配置

再利用可能な関数は`utils/`ディレクトリに配置する：

```typescript
// 良い例 - ユーティリティ関数の分離
// utils/regexValidator.ts - 正規表現バリデーション専用
export class RegexValidator {
  static validate(pattern: string): RegexValidationResult {
    // バリデーションロジック
  }

  static createRegex(pattern: string, flags?: string): RegExp {
    // 安全な正規表現作成
  }
}

// utils/treeBuilder.ts - ツリー構築専用
export class TreeBuilder {
  static buildFileTree(
    files: vscode.Uri[],
    options: TreeBuildOptions = {}
  ): TreeNode[] {
    // ツリー構築ロジック
  }
}

// utils/i18n.ts - 国際化（i18n）専用
export function t(key: string, ...args: unknown[]): string {
  // 翻訳を取得
}

export function initializeI18n(context: vscode.ExtensionContext): void {
  // i18nを初期化（設定変更の監視を開始）
}
```

**utils/の使用指針:**

- 特定のドメインに依存しない汎用的な関数
- 複数のモジュールから使用される共通処理
- 単体テストが容易な純粋関数を推奨
- サービス層とは異なり、状態を持たない静的メソッドを推奨

### 10. 国際化（i18n）機能

国際化機能は`utils/i18n.ts`に集約し、翻訳ファイル（`locales/*.json`）を管理する：

```typescript
// utils/i18n.ts - 国際化機能
import * as vscode from 'vscode';

// 翻訳を取得（プレースホルダー対応）
export function t(key: string, ...args: unknown[]): string {
  // 現在の言語設定から翻訳を取得
  // プレースホルダー（{0}, {1}, ...）を置換
}

// i18nを初期化（設定変更の監視を開始）
export function initializeI18n(context: vscode.ExtensionContext): void {
  // 初期言語設定を読み込む
  // 設定変更を監視して言語が変わったらキャッシュをクリア
  configWatcher = vscode.workspace.onDidChangeConfiguration((event) => {
    if (event.affectsConfiguration('regexFileFinder.language')) {
      // 言語が変わった場合はキャッシュをクリア
      clearTranslationCache();
    }
  });
  context.subscriptions.push(configWatcher);
}
```

**i18n機能の使用例：**

```typescript
// extension.ts - 初期化時に呼び出す
import { initializeI18n, t } from './utils/i18n';

export async function activate(context: vscode.ExtensionContext): Promise<void> {
  // i18nの初期化
  initializeI18n(context);
  
  // その他の初期化...
}

// 各サービス・プロバイダーでの使用
import { t } from '../utils/i18n';

// 単純な翻訳
const message = t('errors.invalidRegex');

// プレースホルダーを使用した翻訳
const message = t('errors.regexError', errorMessage, pattern);

// TreeViewでの使用
treeItem.command = {
  command: 'vscode.open',
  title: t('ui.openFile'),
  arguments: [element.resourceUri],
};
```

**翻訳ファイルの管理：**

- 翻訳ファイルは`locales/`ディレクトリに配置（`locales/ja.json`, `locales/en.json`）
- ネストされたキー構造を使用（例: `errors.invalidRegex`, `ui.openFile`）
- VS Codeの設定（`regexFileFinder.language`）で言語を切り替え可能
- 設定値が`auto`の場合はVS Codeの言語設定から自動検出

## プロジェクト固有の制約事項

- RegexFileFinder は単一機能の拡張機能として設計（v2.0.0以降は検索とリネーム機能を含む）
- 複雑な依存関係は避け、シンプルな構造を維持
- VS Code 拡張機能の制約（バンドルサイズ、パフォーマンス）を考慮
- 将来の機能拡張を考慮した柔軟な設計
- Webview を使用した UI 実装（SearchInputViewProvider）を含む

## 参考資料

- [VS Code Extension Structure](https://code.visualstudio.com/api/extension-guides/overview)
- [Clean Architecture Principles](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
